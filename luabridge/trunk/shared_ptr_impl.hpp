// shared_ptr_impl.hpp
// Implementation of template classes from shared_ptr.hpp
// Should never be included directly, include shared_ptr.hpp instead
// Copyright (C) 2007 by Nathan Reed.  All rights and priveleges reserved.

// Disable "unreachable code" warning generated by hash_map in release build
#pragma warning (push)
#pragma warning (disable: 4702)
#include <hash_map>
#pragma warning (pop)

// Declaration of container for the refcounts
typedef stdext::hash_map<void *, int> refcounts_t;
extern refcounts_t refcounts_;

/*
 * shared_ptr<T> implementation
 */

template <typename T>
shared_ptr<T>::shared_ptr (T* ptr_): ptr(ptr_)
{
	++refcounts_[ptr];
}

template <typename T>
shared_ptr<T>::shared_ptr (const shared_ptr<T>& rhs): ptr(rhs.ptr)
{
	++refcounts_[ptr];
}

template <typename T>
template <typename U>
shared_ptr<T>::shared_ptr (const shared_ptr<U>& rhs):
	ptr(static_cast<T*>(rhs.ptr))
{
	++refcounts_[ptr];
}

template <typename T>
template <typename U>
shared_ptr<T>& shared_ptr<T>::operator = (const shared_ptr<U>& rhs)
{
	release();
	ptr = static_cast<T*>(rhs.ptr);
	++refcounts_[ptr];
	return *this;
}

template <typename T>
T* shared_ptr<T>::get () const
{
	return ptr;
}

template <typename T>
T* shared_ptr<T>::operator * () const
{
	return ptr;
}

template <typename T>
T* shared_ptr<T>::operator -> () const
{
	return ptr;
}

template <typename T>
void shared_ptr<T>::release ()
{
	if (!ptr) return;
	if (--refcounts_[ptr] <= 0)
		delete ptr;
	ptr = 0;
}

template <typename T>
shared_ptr<T>::~shared_ptr ()
{
	release();
}

